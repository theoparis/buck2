searchState.loadedDescShard("starlark_syntax", 0, "Starlark AST.\nContains the error value\nContains the success value\nStarlark call stack.\nA data structure for tracking source positions in language …\nOur string operations (indexing) are O(n) because of our …\nInternal error of starlark.\nThe AST of Starlark as <code>AstModule</code>, along with a <code>parse</code> …\nOwned call stack.\nThe frames.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTake the contained frames.\nIs the call stack empty?\nA data structure recording a source code file for position …\nMultiple <code>CodeMap</code>.\nA file, and a line and column range within it.\nA file, and a line and column range within it.\n“Codemap” for <code>.rs</code> files.\nA small, <code>Copy</code>, value representing a position in a <code>CodeMap</code>…\nFile and line number.\nFile name and line and column pairs for a span.\nAll are 0-based, but print out with 1-based.\nThe locations of values within a span. All are 0-based, …\nA range of text within a CodeMap.\nAssociate a Span with a value of arbitrary type (e.g. an …\nAdd codemap if not already present.\nAdd all codemaps.\nCheap reference to the span.\nThe position at the first byte of the span.\nBeginning of the span.\nFile and line number of the beginning of the span.\nThe column within the line (0-indexed in characters).\nDetermines whether a <code>pos</code> is within this span.\nCheck that the given position is contained within this …\nThe position after the last byte of the span.\nEnd of the span.\nEmpty span in the end of this span.\nCompares by identity\nFile name.\nFile name.\nGets the file and its line and column ranges represented …\nGets the name of the file\nFilename of this reference.\nFilename of this span.\nGets the line number of a Pos.\nFormats the span as …\nFormats the span as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the value.\nLookup by id.\nOnly used internally for profiling optimisations\nDetermines whether a <code>span</code> intersects with this span. End …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe line number within the file (0-indexed).\nLine number is 0-based but displayed as 1-based.\nLike <code>line_span_opt</code> but panics if the line number is out of …\nGets the span representing a line by line number.\nTrim trailing newline if any, including windows, from the …\nApply the function to the node, keep the span.\nCreate a span that encloses both <code>self</code> and <code>other</code>.\nConstructor.\nCreate a new span. Panics if <code>end &lt; begin</code>.\nCreates an new <code>CodeMap</code>.\nCreates an new <code>FileSpan</code> covering the entire file.\nData in the node.\nResolve the span to lines and columns.\nResolve span offsets to lines and columns.\nResolve the span to lines and columns.\nGets the full source text of the file\nGets the source text of a line.\nGets the source text of a Span.\nResolve the span.\nResolve the span.\nThe span.\nConvert to the owned span.\nA value of type <code>T</code>, together with some diagnostic …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSet the <code>call_stack</code> field, unless it’s already been set.\nSet the span, unless it’s already been set.\nStarlark language features to enable, e.g. <code>Standard</code> to …\nHow to handle type annotations in Starlark.\nProhibit types at parse time.\nCheck types at runtime.\nAllow types at parse time, but ignore types at runtime.\nFollow the Starlark language standard as much as possible.\nLike <code>#[non_exhaustive]</code>, but allows struct expression.\nAre <code>def</code> statements permitted. Enabled by default.\nAre <code>f&quot;{expression}&quot;</code> strings supported? Only works where …\nAre <code>*</code> keyword-only arguments allowed as per PEP 3102. …\nAre <code>lambda</code> expressions permitted. Enabled by default.\nAre <code>load</code> statements permitted. Enabled by default.\nDo <code>load()</code> statements reexport their definition. Enabled by …\nAre <code>/</code> for positional-only arguments allowed.\nAre <code>for</code>, <code>if</code> and other statements allowed at the top level. …\nAre expressions allowed in type positions as per PEP 484. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmitted when processing an escape (<code>{{</code> or <code>}}</code>).\nOutput the capture as <code>str</code> or <code>repr</code>.\nParser for <code>.format()</code> arguments.\nToken in the format string.\nText to copy verbatim to the output.\nGet what this represents.\nGet back the escaped form for this.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse the next token from the format string.\nFormat part inside curly braces before the conversion.\nThe conversion to apply to this capture.\nThe position of this capture. This does not include the …\nAn error produced by starlark.\nThe different kinds of errors that can be produced by …\nAn explicit <code>fail</code> invocation\nFreeze errors. Should have no metadata attached\nErrors relating to the way a function is called (wrong …\nIndicates a logic bug in starlark\nError from user provided native function (but not from …\nFallback option\nSyntax error.\nOut of scope variables and similar\nStarlark call stack overflow.\nAn error approximately associated with a value.\nPrint an error to the stderr stream. If the error has …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this error into an <code>anyhow::Error</code>\nChange error kind to internal error.\nConvert the error into the underlying kind\nThe kind of this error\nCreate a new error\nCreate a new error with no diagnostic and of kind …\nCreate a new error with no diagnostic and of kind …\nCreate a new error with a span\nCreate a new error with no diagnostic and of kind …\nSet the <code>call_stack</code> field, unless it’s already been set.\nSet the span, unless it’s already been set.\nThe source of the error, akin to …\nReturns a value that can be used to format this error …\nError with location.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>EvalException</code> is meant to provide type-safe guard against …\nIndex of a char in a string. This is different from string …\nResult of applying <code>start</code> and <code>end</code> to a string.\nFind the character at position <code>i</code>.\nConvert common <code>start</code> and <code>end</code> arguments of <code>str</code> functions …\nFind the number of times a <code>needle</code> occurs within a string, …\nFind the number of times a <code>needle</code> byte occurs within a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nSubstring after applying the <code>start</code> and <code>end</code> arguments.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFind the length of the string in characters. If the length …\nSplit the string at given char offset. <code>None</code> if offset is …\nComputed start char index.\nA frame of the call-stack.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe location of the definition, or <code>None</code> for native Rust …\nThe name of the entry on the call-stack.\nCommon code for golden tests.\nOnly if larger than <code>i32</code>.\nComment as token. Span includes the leading <code>#</code>, but the …\nThe raw text of a f-string\nThe start of a double-quoted f-string.\nThe start of a single-quoted f-string.\nAll token that can be generated by the lexer\nThe content of this TokenFString\nRelative to the token, where does the actual string …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtension traits on slices/<code>Vec</code>.\nExtension traits on <code>Vec</code>.\nA shorthand for <code>into_iter().map(f).collect::&lt;Vec&lt;_&gt;&gt;()</code>. …\nA shorthand for …\nA shorthand for <code>iter().map(f).collect::&lt;Vec&lt;_&gt;&gt;()</code>. For …\nA shorthand for …\nGets annotated snippets.\nAST for parsed starlark files.\nCode called by the parser to handle complex cases not …\nMap AST payload.\nAST for parsed starlark files.\nIdentifier in assign position.\n<code>x: t = y</code>.\nIn some places e.g. AssignModify, the Tuple case is not …\nDefault implementation of payload, which attaches <code>()</code> to …\nPayload types attached to AST nodes.\n<code>,</code> token.\nIdentifier in read position, e. g. <code>foo</code> in <code>[foo.bar]</code>. <code>foo</code> …\nArgument of <code>load</code> statement.\n<code>load</code> statement.\n<code>*</code> marker.\n<code>*</code> marker.\n<code>/</code> marker.\n<code>/</code> marker.\nRestricted expression at type position.\nTrailing comma.\nCurrently it is an expr. Planning to restrict it. Context.\nCurrently it is an expr. Planning to restrict it. Context.\nThe expressions to interpolate.\nA format string containing a <code>{}</code> marker for each expression …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>x in </code>x=“y”`.\nArgument name if it is named.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\nData in the node.\n<code>&quot;y&quot; in </code>x=“y”`.\nVisit children expressions.\nVisit all identifiers in read position recursively.\nAssuming this expression was on the left-hand-side of an …\nVisit all type expressions in this statement and its …\nValidated call arguments.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOne function parameter.\nParameters internally in starlark-rust are commonly …\nPost-processed AST for function parameters.\nIndex of <code>*args</code> parameter, if any. If present, equal to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nName of the parameter.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this is a regular parameter (with optional …\nIndex of <code>**kwargs</code> parameter, if any. If present, equal to …\nNumber of parameters which can be filled positionally. …\nNumber of parameters which can only be filled positionally.\nType of the parameter. This is None when a type is not …\nEnsure we produce normalised Statements, rather than …\nA representation of a Starlark module abstract syntax tree.\nThis trait is not exported as public API of starlark.\nLook up a <code>Span</code> contained in this module to a <code>FileSpan</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if a given Lint short_name and span is suppressed in …\nReturn the file names of all the <code>load</code> statements in the …\nParse a Starlark module to produce an <code>AstModule</code>, or an …\nParse a file stored on disk. For details see <code>parse</code>.\nFunction to help people who want to write deeper AST …\nGet back the AST statement for the module\nLocations where statements occur.\nA <code>load</code> statement loading zero or more symbols from another …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nModule being loaded\nSpan where this load is written\nSymbols loaded from that module (local ident -&gt; source …\nList the top-level statements in the AST.\nList the top-level statements in the AST.\n<code>list[str]</code>.\n<code>dict[str, int]</code> or <code>typing.Callable[[int], str]</code>.\nList argument in <code>typing.Callable[[int], str]</code>.\nThis type should be used instead of <code>TypeExprP</code>, but a lot …\nPath component of type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTypes that are <code>&quot;&quot;</code> or start with <code>&quot;_&quot;</code> are wildcard - they …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")