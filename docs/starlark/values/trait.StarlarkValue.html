<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="How to put a Rust values into `Value`s."><title>StarlarkValue in starlark::values - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-069232aa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="starlark" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (2fd855fbf 2025-08-07)" data-channel="nightly" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../starlark/index.html">starlark</a><span class="version">0.13.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Starlark<wbr>Value</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#note-to-implementors" title="Note To Implementors">Note To Implementors</a></li></ul><h3><a href="#provided-associated-consts">Provided Associated Constants</a></h3><ul class="block"><li><a href="#associatedconstant.TYPE" title="TYPE">TYPE</a></li></ul><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.Canonical" title="Canonical">Canonical</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.add" title="add">add</a></li><li><a href="#method.at" title="at">at</a></li><li><a href="#method.at2" title="at2">at2</a></li><li><a href="#method.attr_ty" title="attr_ty">attr_ty</a></li><li><a href="#method.bin_op_ty" title="bin_op_ty">bin_op_ty</a></li><li><a href="#method.bit_and" title="bit_and">bit_and</a></li><li><a href="#method.bit_not" title="bit_not">bit_not</a></li><li><a href="#method.bit_or" title="bit_or">bit_or</a></li><li><a href="#method.bit_xor" title="bit_xor">bit_xor</a></li><li><a href="#method.collect_repr" title="collect_repr">collect_repr</a></li><li><a href="#method.collect_repr_cycle" title="collect_repr_cycle">collect_repr_cycle</a></li><li><a href="#method.compare" title="compare">compare</a></li><li><a href="#method.dir_attr" title="dir_attr">dir_attr</a></li><li><a href="#method.div" title="div">div</a></li><li><a href="#method.documentation" title="documentation">documentation</a></li><li><a href="#method.equals" title="equals">equals</a></li><li><a href="#method.export_as" title="export_as">export_as</a></li><li><a href="#method.floor_div" title="floor_div">floor_div</a></li><li><a href="#method.get_attr" title="get_attr">get_attr</a></li><li><a href="#method.get_attr_hashed" title="get_attr_hashed">get_attr_hashed</a></li><li><a href="#method.get_methods" title="get_methods">get_methods</a></li><li><a href="#method.get_type_starlark_repr" title="get_type_starlark_repr">get_type_starlark_repr</a></li><li><a href="#method.get_type_value_static" title="get_type_value_static">get_type_value_static</a></li><li><a href="#method.has_attr" title="has_attr">has_attr</a></li><li><a href="#method.invoke" title="invoke">invoke</a></li><li><a href="#method.is_in" title="is_in">is_in</a></li><li><a href="#method.iter_next" title="iter_next">iter_next</a></li><li><a href="#method.iter_size_hint" title="iter_size_hint">iter_size_hint</a></li><li><a href="#method.iter_stop" title="iter_stop">iter_stop</a></li><li><a href="#method.iterate" title="iterate">iterate</a></li><li><a href="#method.iterate_collect" title="iterate_collect">iterate_collect</a></li><li><a href="#method.left_shift" title="left_shift">left_shift</a></li><li><a href="#method.length" title="length">length</a></li><li><a href="#method.minus" title="minus">minus</a></li><li><a href="#method.mul" title="mul">mul</a></li><li><a href="#method.name_for_call_stack" title="name_for_call_stack">name_for_call_stack</a></li><li><a href="#method.percent" title="percent">percent</a></li><li><a href="#method.plus" title="plus">plus</a></li><li><a href="#method.provide" title="provide">provide</a></li><li><a href="#method.radd" title="radd">radd</a></li><li><a href="#method.rbin_op_ty" title="rbin_op_ty">rbin_op_ty</a></li><li><a href="#method.right_shift" title="right_shift">right_shift</a></li><li><a href="#method.rmul" title="rmul">rmul</a></li><li><a href="#method.set_at" title="set_at">set_at</a></li><li><a href="#method.set_attr" title="set_attr">set_attr</a></li><li><a href="#method.slice" title="slice">slice</a></li><li><a href="#method.sub" title="sub">sub</a></li><li><a href="#method.to_bool" title="to_bool">to_bool</a></li><li><a href="#method.try_freeze_directly" title="try_freeze_directly">try_freeze_directly</a></li><li><a href="#method.typechecker_ty" title="typechecker_ty">typechecker_ty</a></li><li><a href="#method.write_hash" title="write_hash">write_hash</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In starlark::<wbr>values</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">starlark</a>::<wbr><a href="index.html">values</a></div><h1>Trait <span class="trait">StarlarkValue</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/starlark/values/traits.rs.html#240-911">Source</a> </span></div><pre class="rust item-decl"><code>pub trait StarlarkValue&lt;'v&gt;:
    'v
    + <a class="trait" href="../any/trait.ProvidesStaticType.html" title="trait starlark::any::ProvidesStaticType">ProvidesStaticType</a>&lt;'v&gt;
    + Allocative
    + <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>
    + <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>
    + <a class="trait" href="https://docs.rs/erased-serde/0.3.31/erased_serde/ser/trait.Serialize.html" title="trait erased_serde::ser::Serialize">Serialize</a>
    + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> {
    type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a>: <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt;;

    const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = _;
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 51 methods</span></summary>
    // Provided methods
    fn <a href="#method.get_type_value_static" class="fn">get_type_value_static</a>() -&gt; <a class="type" href="type.FrozenStringValue.html" title="type starlark::values::FrozenStringValue">FrozenStringValue</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.get_type_starlark_repr" class="fn">get_type_starlark_repr</a>() -&gt; <a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.get_methods" class="fn">get_methods</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'static <a class="struct" href="../environment/struct.Methods.html" title="struct starlark::environment::Methods">Methods</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.documentation" class="fn">documentation</a>(&amp;self) -&gt; <a class="enum" href="../docs/enum.DocItem.html" title="enum starlark::docs::DocItem">DocItem</a>
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.typechecker_ty" class="fn">typechecker_ty</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.collect_repr" class="fn">collect_repr</a>(&amp;self, collector: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.collect_repr_cycle" class="fn">collect_repr_cycle</a>(&amp;self, collector: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.name_for_call_stack" class="fn">name_for_call_stack</a>(&amp;self, me: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_bool" class="fn">to_bool</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_hash" class="fn">write_hash</a>(&amp;self, hasher: &amp;mut <a class="struct" href="../collections/struct.StarlarkHasher.html" title="struct starlark::collections::StarlarkHasher">StarlarkHasher</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.equals" class="fn">equals</a>(&amp;self, _other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.compare" class="fn">compare</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.invoke" class="fn">invoke</a>(
        &amp;self,
        _me: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
        _args: &amp;<a class="struct" href="../eval/struct.Arguments.html" title="struct starlark::eval::Arguments">Arguments</a>&lt;'v, '_&gt;,
        _eval: &amp;mut <a class="struct" href="../eval/struct.Evaluator.html" title="struct starlark::eval::Evaluator">Evaluator</a>&lt;'v, '_, '_&gt;,
    ) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.at" class="fn">at</a>(&amp;self, index: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.at2" class="fn">at2</a>(
        &amp;self,
        _index0: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
        _index1: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
        _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
        _private: Private,
    ) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.slice" class="fn">slice</a>(
        &amp;self,
        _start: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;,
        _stop: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;,
        _stride: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;,
        _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
    ) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.iterate_collect" class="fn">iterate_collect</a>(&amp;self, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt; { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.iterate" class="fn">iterate</a>(
        &amp;self,
        _me: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
        heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
    ) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.iter_size_hint" class="fn">iter_size_hint</a>(&amp;self, _index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.iter_next" class="fn">iter_next</a>(
        &amp;self,
        _index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
        _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.iter_stop" class="fn">iter_stop</a>(&amp;self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.length" class="fn">length</a>(&amp;self) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.attr_ty" class="fn">attr_ty</a>(_name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.get_attr" class="fn">get_attr</a>(&amp;self, _attribute: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.get_attr_hashed" class="fn">get_attr_hashed</a>(
        &amp;self,
        attribute: <a class="struct" href="../collections/struct.Hashed.html" title="struct starlark::collections::Hashed">Hashed</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,
        heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.has_attr" class="fn">has_attr</a>(&amp;self, attribute: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.dir_attr" class="fn">dir_attr</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_in" class="fn">is_in</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.plus" class="fn">plus</a>(&amp;self, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.minus" class="fn">minus</a>(&amp;self, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.radd" class="fn">radd</a>(
        &amp;self,
        _lhs: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
        _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.add" class="fn">add</a>(&amp;self, _rhs: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.sub" class="fn">sub</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rmul" class="fn">rmul</a>(&amp;self, lhs: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.mul" class="fn">mul</a>(&amp;self, _rhs: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.div" class="fn">div</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.percent" class="fn">percent</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.floor_div" class="fn">floor_div</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.bit_and" class="fn">bit_and</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.bit_or" class="fn">bit_or</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.bit_xor" class="fn">bit_xor</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.bit_not" class="fn">bit_not</a>(&amp;self, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.left_shift" class="fn">left_shift</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.right_shift" class="fn">right_shift</a>(
        &amp;self,
        other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
        _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
    ) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.bin_op_ty" class="fn">bin_op_ty</a>(_op: <a class="enum" href="../typing/enum.TypingBinOp.html" title="enum starlark::typing::TypingBinOp">TypingBinOp</a>, _rhs: &amp;<a class="enum" href="../typing/enum.TyBasic.html" title="enum starlark::typing::TyBasic">TyBasic</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rbin_op_ty" class="fn">rbin_op_ty</a>(_lhs: &amp;<a class="enum" href="../typing/enum.TyBasic.html" title="enum starlark::typing::TyBasic">TyBasic</a>, _op: <a class="enum" href="../typing/enum.TypingBinOp.html" title="enum starlark::typing::TypingBinOp">TypingBinOp</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.export_as" class="fn">export_as</a>(
        &amp;self,
        _variable_name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
        _eval: &amp;mut <a class="struct" href="../eval/struct.Evaluator.html" title="struct starlark::eval::Evaluator">Evaluator</a>&lt;'v, '_, '_&gt;,
    ) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.set_at" class="fn">set_at</a>(&amp;self, _index: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _new_value: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.set_attr" class="fn">set_attr</a>(&amp;self, attribute: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, _new_value: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.provide" class="fn">provide</a>(&amp;'v self, demand: &amp;mut <a class="struct" href="struct.Demand.html" title="struct starlark::values::Demand">Demand</a>&lt;'_, 'v&gt;) { ... }
<span class="item-spacer"></span>    fn <a href="#method.try_freeze_directly" class="fn">try_freeze_directly</a>(
        &amp;self,
        _freezer: &amp;<a class="struct" href="struct.Freezer.html" title="struct starlark::values::Freezer">Freezer</a>&lt;'_&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.FreezeResult.html" title="type starlark::values::FreezeResult">FreezeResult</a>&lt;<a class="struct" href="struct.FrozenValue.html" title="struct starlark::values::FrozenValue">FrozenValue</a>&gt;&gt; { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>How to put a Rust values into <a href="struct.Value.html" title="struct starlark::values::Value"><code>Value</code></a>s.</p>
<p>Every Rust value stored in a <a href="struct.Value.html" title="struct starlark::values::Value"><code>Value</code></a> must implement this trait.
You <em>must</em> also implement <a href="trait.ComplexValue.html" title="trait starlark::values::ComplexValue"><code>ComplexValue</code></a> if:</p>
<ul>
<li>A type is not <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send"><code>Send</code></a> and <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync"><code>Sync</code></a>, typically because it contains
interior mutability such as a <a href="https://doc.rust-lang.org/nightly/core/cell/struct.RefCell.html" title="struct core::cell::RefCell"><code>RefCell</code></a>.</li>
<li>A type contains nested Starlark <a href="struct.Value.html" title="struct starlark::values::Value"><code>Value</code></a>s.</li>
</ul>
<p>There are only two required members of <a href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue"><code>StarlarkValue</code></a>, namely
<a href="trait.StarlarkValue.html#associatedconstant.TYPE" title="associated constant starlark::values::StarlarkValue::TYPE"><code>TYPE</code></a>
and <a href="trait.StarlarkValue.html#method.get_type_value_static" title="associated function starlark::values::StarlarkValue::get_type_value_static"><code>get_type_value_static</code></a>.
Both these should be implemented with the <a href="attr.starlark_value.html" title="attr starlark::values::starlark_value"><code>starlark_value</code></a>
proc macro:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>allocative::Allocative;
<span class="kw">use </span>derive_more::Display;
<span class="kw">use </span>starlark::values::NoSerialize;
<span class="kw">use </span>starlark::values::ProvidesStaticType;
<span class="kw">use </span>starlark::values::StarlarkValue;
<span class="kw">use </span>starlark_derive::starlark_value;

<span class="attr">#[derive(Debug, Display, ProvidesStaticType, NoSerialize, Allocative)]
#[display(<span class="string">"Foo"</span>)]
</span><span class="kw">struct </span>Foo;
<span class="attr">#[starlark_value(<span class="kw">type </span>= <span class="string">"foo"</span>)]
</span><span class="kw">impl</span>&lt;<span class="lifetime">'v</span>&gt; StarlarkValue&lt;<span class="lifetime">'v</span>&gt; <span class="kw">for </span>Foo {}</code></pre></div>
<p>Every additional field enables further features in Starlark. In most cases the default
implementation returns an “unimplemented” <a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>.</p>
<h2 id="note-to-implementors"><a class="doc-anchor" href="#note-to-implementors">§</a>Note To Implementors</h2>
<p>Any additional methods that are added to this trait also need to be added to the
<a href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue"><code>StarlarkValue</code></a> implementation in <code>crate::values::layout::avalue::Wrapper</code>. Otherwise,
any implementations other than the default implementation will not be run.</p>
</div></details><h2 id="provided-associated-consts" class="section-header">Provided Associated Constants<a href="#provided-associated-consts" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedconstant.TYPE" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#256">Source</a><h4 class="code-header">const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = _</h4></section></summary><div class="docblock"><p>Return a string describing the type of self, as returned by the type()
function.</p>
<p>This can be only implemented by the <a href="attr.starlark_value.html" title="attr starlark::values::starlark_value"><code>#[starlark_value]</code></a>
proc macro.</p>
</div></details></div><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.Canonical" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#249">Source</a><h4 class="code-header">type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a>: <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt;</h4></section></summary><div class="docblock"><p>Two implementations of <code>StarlarkValue</code> are considered to have the same type,
if <code>Canonical</code> field points to the same type.</p>
<p>This field is generated by <code>#[starlark_value]</code> proc macro by default
when proc macro can infer the type, otherwise this implementation cannot serve as a type.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.get_type_value_static" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#264-266">Source</a><h4 class="code-header">fn <a href="#method.get_type_value_static" class="fn">get_type_value_static</a>() -&gt; <a class="type" href="type.FrozenStringValue.html" title="type starlark::values::FrozenStringValue">FrozenStringValue</a></h4></section></summary><div class="docblock"><p>Like <a href="trait.StarlarkValue.html#associatedconstant.TYPE"><code>TYPE</code></a>, but returns a reusable <a href="type.FrozenStringValue.html" title="type starlark::values::FrozenStringValue"><code>FrozenStringValue</code></a>
pointer to it. This function deliberately doesn’t take a heap,
as it would not be performant to allocate a new value each time.</p>
<p>This can be only implemented by the <a href="attr.starlark_value.html" title="attr starlark::values::starlark_value"><code>#[starlark_value]</code></a>
proc macro.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_type_starlark_repr" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#274-276">Source</a><h4 class="code-header">fn <a href="#method.get_type_starlark_repr" class="fn">get_type_starlark_repr</a>() -&gt; <a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a></h4></section></summary><div class="docblock"><p>Return a string that is the representation of a type that a user would use in
type annotations. This often will be the same as <a href="trait.StarlarkValue.html#associatedconstant.TYPE"><code>Self::TYPE</code></a>, but in
some instances it might be slightly different than what is returned by <code>TYPE</code>.</p>
<p>This can be only implemented by the <a href="attr.starlark_value.html" title="attr starlark::values::starlark_value"><code>#[starlark_value]</code></a>
proc macro.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_methods" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#307-312">Source</a><h4 class="code-header">fn <a href="#method.get_methods" class="fn">get_methods</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'static <a class="struct" href="../environment/struct.Methods.html" title="struct starlark::environment::Methods">Methods</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Get the members associated with this type, accessible via <code>this_type.x</code>.
These members will have <code>dir</code>/<code>getattr</code>/<code>hasattr</code> properly implemented,
so it is the preferred way to go if possible. See
<a href="../environment/struct.MethodsStatic.html" title="struct starlark::environment::MethodsStatic"><code>MethodsStatic</code></a> for an example of how
to define this method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.documentation" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#319-330">Source</a><h4 class="code-header">fn <a href="#method.documentation" class="fn">documentation</a>(&amp;self) -&gt; <a class="enum" href="../docs/enum.DocItem.html" title="enum starlark::docs::DocItem">DocItem</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Return the documentation for this value.</p>
<p>This should be the doc-item that is expected to be generated when this value appears as a
global in a module. In other words, for normal types this should generally return a
<code>DocMember::Property</code>. In that case there is no need to override this method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.typechecker_ty" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#334-338">Source</a><h4 class="code-header">fn <a href="#method.typechecker_ty" class="fn">typechecker_ty</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a>&gt;</h4></section></summary><div class="docblock"><p>Type of this instance for typechecker.
Note this can be more precise than generic type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.collect_repr" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#360-363">Source</a><h4 class="code-header">fn <a href="#method.collect_repr" class="fn">collect_repr</a>(&amp;self, collector: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>)</h4></section></summary><div class="docblock"><p>Return a string representation of self, as returned by the <code>repr()</code> function.
Defaults to the <code>Display</code> instance - which should be fine for nearly all types.
In many cases the <code>repr()</code> representation will also be a Starlark expression
for creating the value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>repr(<span class="string">"test"</span>) == <span class="string">'"test"'
</span>repr([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) == <span class="string">'[1, 2, 3]'
</span>repr([<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]) == <span class="string">'[1, [2, 3]]'
</span>repr([<span class="number">1</span>]) == <span class="string">'[1]'
</span>repr([]) == <span class="string">'[]'</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.collect_repr_cycle" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#366-368">Source</a><h4 class="code-header">fn <a href="#method.collect_repr_cycle" class="fn">collect_repr_cycle</a>(&amp;self, collector: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>)</h4></section></summary><div class="docblock"><p>Invoked to print <code>repr</code> when a cycle is the object stack is detected.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.name_for_call_stack" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#371-373">Source</a><h4 class="code-header">fn <a href="#method.name_for_call_stack" class="fn">name_for_call_stack</a>(&amp;self, me: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>String used when printing call stack. <code>repr(self)</code> by default.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_bool" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#377-381">Source</a><h4 class="code-header">fn <a href="#method.to_bool" class="fn">to_bool</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Convert self to a boolean, as returned by the bool() function.
The default implementation returns <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html" title="primitive bool"><code>true</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_hash" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#386-401">Source</a><h4 class="code-header">fn <a href="#method.write_hash" class="fn">write_hash</a>(&amp;self, hasher: &amp;mut <a class="struct" href="../collections/struct.StarlarkHasher.html" title="struct starlark::collections::StarlarkHasher">StarlarkHasher</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Return a hash data for self to be used when self is placed as a key in a <code>Dict</code>.
Return an <a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> if there is no hash for this value (e.g. list).
Must be stable between frozen and non-frozen values.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.equals" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#422-425">Source</a><h4 class="code-header">fn <a href="#method.equals" class="fn">equals</a>(&amp;self, _other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Compare <code>self</code> with <code>other</code> for equality.
Should only return an error on excessive recursion.</p>
<p>This function can only be called when it is known that self pointer
is not equal to the other pointer. Thus, an implementation may assume
that the pointers are not equal. Implementation of <code>equals</code> for some
builtin types and default implementation rely on this assumption.</p>
<p>Equality must be symmetric (<code>a == b</code> implies <code>b == a</code>).
When evaluating <code>a == b</code> (or when using equality in dicts and such),
it is not specified whether <code>a.equals(b)</code> or <code>b.equals(a)</code> is called.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compare" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#430-432">Source</a><h4 class="code-header">fn <a href="#method.compare" class="fn">compare</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class="docblock"><p>Compare <code>self</code> with <code>other</code>.
This method returns a result of type <a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a>, or an <a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>
if the two types differ.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.invoke" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#441-448">Source</a><h4 class="code-header">fn <a href="#method.invoke" class="fn">invoke</a>(
    &amp;self,
    _me: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
    _args: &amp;<a class="struct" href="../eval/struct.Arguments.html" title="struct starlark::eval::Arguments">Arguments</a>&lt;'v, '_&gt;,
    _eval: &amp;mut <a class="struct" href="../eval/struct.Evaluator.html" title="struct starlark::eval::Evaluator">Evaluator</a>&lt;'v, '_, '_&gt;,
) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Directly invoke a function.
The number of <code>named</code> and <code>names</code> arguments are guaranteed to be equal.</p>
<h5 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h5>
<ul>
<li><code>me</code> - self, but as <code>Value</code>, meaning it has unfrozen flag,
so it can be stored in a heap.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.at" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#451-453">Source</a><h4 class="code-header">fn <a href="#method.at" class="fn">at</a>(&amp;self, index: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Return the result of <code>a[index]</code> if <code>a</code> is indexable.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.at2" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#456-464">Source</a><h4 class="code-header">fn <a href="#method.at2" class="fn">at2</a>(
    &amp;self,
    _index0: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
    _index1: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;,
    _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
    _private: Private,
) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Return the result of <code>a[index0, index1]</code> if <code>a</code> is indexable by two parameters.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#490-498">Source</a><h4 class="code-header">fn <a href="#method.slice" class="fn">slice</a>(
    &amp;self,
    _start: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;,
    _stop: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;,
    _stride: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;,
    _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Extract a slice of the underlying object if the object is indexable. The
result will be object between <code>start</code> and <code>stop</code> (both of them are
added length() if negative and then clamped between 0 and length()).
<code>stride</code> indicates the direction.</p>
<h5 id="parameters-1"><a class="doc-anchor" href="#parameters-1">§</a>Parameters</h5>
<ul>
<li>start: the start of the slice.</li>
<li>stop: the end of the slice.</li>
<li>stride: the direction of slice,</li>
</ul>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="string">'abc'</span>[<span class="number">1</span>:] == <span class="string">'bc'         </span># Remove the first element
<span class="string">'abc'</span>[:-<span class="number">1</span>] == <span class="string">'ab'        </span># Remove the last element
<span class="string">'abc'</span>[<span class="number">1</span>:-<span class="number">1</span>] == <span class="string">'b'        </span># Remove the first and the last element
<span class="string">'abc'</span>[-<span class="number">1</span>:] == <span class="string">'c'         </span># Take the last letter
<span class="string">'abc'</span>[:<span class="number">1</span>] == <span class="string">'a'          </span># Take the first letter
<span class="string">'banana'</span>[<span class="number">1</span>::<span class="number">2</span>] == <span class="string">'aaa'   </span># Select one element out of <span class="number">2</span>, skipping the first
<span class="string">'banana'</span>[<span class="number">4</span>::-<span class="number">2</span>] == <span class="string">'nnb'  </span># Select one element out of <span class="number">2 </span><span class="kw">in </span>reverse order, starting at index <span class="number">4</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iterate_collect" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#503-505">Source</a><h4 class="code-header">fn <a href="#method.iterate_collect" class="fn">iterate_collect</a>(&amp;self, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Implement iteration over the value of this container by providing
the values in a <code>Vec</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iterate" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#532-534">Source</a><h4 class="code-header">unsafe fn <a href="#method.iterate" class="fn">iterate</a>(&amp;self, _me: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the value of this container if this value holds
an iterable container.</p>
<p><strong>This function is hard to implement correctly.</strong>
For example, returning a list from this function is memory violation,
because the list object acting as an iterator is assumed
to have the iteration lock acquired.</p>
<p>Consider implementing <a href="trait.StarlarkValue.html#method.iterate_collect"><code>iterate_collect</code></a> instead
when possible.</p>
<p>This function calls <a href="trait.StarlarkValue.html#method.iterate_collect"><code>iterate_collect</code></a> by default.</p>
<p>Returned iterator value must implement
<a href="trait.StarlarkValue.html#method.iter_next"><code>iter_next</code></a> and <a href="trait.StarlarkValue.html#method.iter_stop"><code>iter_stop</code></a>.
Default implementations of these functions panic.</p>
<p>Starlark-rust guarantees that</p>
<ul>
<li><code>iter_next</code> and <code>iter_stop</code> are only called on the value returned from <code>iterate</code></li>
<li><code>iter_next</code> is called only before <code>iter_stop</code></li>
<li><code>iter_stop</code> is called exactly once</li>
</ul>
<p>So implementations of iterators may acquire mutation lock in <code>iterate</code>,
assume that it is held in <code>iter_next</code>, and release it in <code>iter_stop</code>.
Obviously, there are no such guarantees if these functions are called directly.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_size_hint" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#537-539">Source</a><h4 class="code-header">unsafe fn <a href="#method.iter_size_hint" class="fn">iter_size_hint</a>(&amp;self, _index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;)</h4></section></summary><div class="docblock"><p>Returns the size hint for the iterator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_next" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#553-558">Source</a><h4 class="code-header">unsafe fn <a href="#method.iter_next" class="fn">iter_next</a>(&amp;self, _index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Yield the next value from the iterator.</p>
<p>This function is called on the iterator value returned by <a href="trait.StarlarkValue.html#method.iterate"><code>iterate</code></a>.
This function accepts an index, which starts at 0 and is incremented by 1
for each call to <code>iter_next</code>. The index can be used to implement
cheap iteration over simple containers like lists:
list <a href="trait.StarlarkValue.html#method.iterate"><code>iterate</code></a> just returns the list itself,
and the passed index is used to access the list elements.</p>
<p>Default implementation panics.</p>
<p>This function is only called before <a href="trait.StarlarkValue.html#method.iter_stop"><code>iter_stop</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_stop" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#566-571">Source</a><h4 class="code-header">unsafe fn <a href="#method.iter_stop" class="fn">iter_stop</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Indicate that the iteration is finished.</p>
<p>This function is typically used to release mutation lock.
The function must be implemented for iterators even if it does nothing.</p>
<p>This function is called exactly once for the iterator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.length" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#574-576">Source</a><h4 class="code-header">fn <a href="#method.length" class="fn">length</a>(&amp;self) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the length of the value, if this value is a sequence.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.attr_ty" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#582-584">Source</a><h4 class="code-header">fn <a href="#method.attr_ty" class="fn">attr_ty</a>(_name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a>&gt;</h4></section></summary><div class="docblock"><p>Attribute type, for the typechecker.</p>
<p>If <a href="trait.StarlarkValue.html#method.get_attr" title="method starlark::values::StarlarkValue::get_attr"><code>get_attr</code></a> is implemented,
<code>#[starlark_value]</code> proc macro will generate this to return <code>Some(Any)</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_attr" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#594-596">Source</a><h4 class="code-header">fn <a href="#method.get_attr" class="fn">get_attr</a>(&amp;self, _attribute: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Get an attribute for the current value as would be returned by dotted
expression (i.e. <code>a.attribute</code>).</p>
<p>The three methods <a href="trait.StarlarkValue.html#method.get_attr" title="method starlark::values::StarlarkValue::get_attr"><code>get_attr</code></a>,
<a href="trait.StarlarkValue.html#method.has_attr" title="method starlark::values::StarlarkValue::has_attr"><code>has_attr</code></a> and <a href="trait.StarlarkValue.html#method.dir_attr" title="method starlark::values::StarlarkValue::dir_attr"><code>dir_attr</code></a>
must be consistent - if you implement one, you should probably implement all three.</p>
<p>This operations must have no side effects, because it can be called speculatively.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_attr_hashed" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#604-606">Source</a><h4 class="code-header">fn <a href="#method.get_attr_hashed" class="fn">get_attr_hashed</a>(
    &amp;self,
    attribute: <a class="struct" href="../collections/struct.Hashed.html" title="struct starlark::collections::Hashed">Hashed</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,
    heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>A version of <code>get_attr</code> which takes <code>BorrowHashed&lt;str&gt;</code> instead of <code>&amp;str</code>,
thus implementation may reuse the hash of the string if this is called
repeatedly with the same string.</p>
<p>This function is optional, but if it is implemented, it must be consistent with
<a href="trait.StarlarkValue.html#method.get_attr"><code>get_attr</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_attr" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#616-618">Source</a><h4 class="code-header">fn <a href="#method.has_attr" class="fn">has_attr</a>(&amp;self, attribute: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if an attribute of name <code>attribute</code> exists for the current
value.</p>
<p>The three methods <a href="trait.StarlarkValue.html#method.get_attr" title="method starlark::values::StarlarkValue::get_attr"><code>get_attr</code></a>,
<a href="trait.StarlarkValue.html#method.has_attr" title="method starlark::values::StarlarkValue::has_attr"><code>has_attr</code></a> and <a href="trait.StarlarkValue.html#method.dir_attr" title="method starlark::values::StarlarkValue::dir_attr"><code>dir_attr</code></a>
must be consistent.</p>
<p>Default implementation of this function delegates to <a href="trait.StarlarkValue.html#method.get_attr"><code>get_attr</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dir_attr" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#625-627">Source</a><h4 class="code-header">fn <a href="#method.dir_attr" class="fn">dir_attr</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Return a vector of string listing all attribute of the current value.</p>
<p>The three methods <a href="trait.StarlarkValue.html#method.get_attr" title="method starlark::values::StarlarkValue::get_attr"><code>get_attr</code></a>,
<a href="trait.StarlarkValue.html#method.has_attr" title="method starlark::values::StarlarkValue::has_attr"><code>has_attr</code></a> and <a href="trait.StarlarkValue.html#method.dir_attr" title="method starlark::values::StarlarkValue::dir_attr"><code>dir_attr</code></a>
must be consistent - if you implement one, you should probably implement all three.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_in" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#640-642">Source</a><h4 class="code-header">fn <a href="#method.is_in" class="fn">is_in</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Tell whether <code>other</code> is in the current value, if it is a container.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>(<span class="string">'a' </span><span class="kw">in </span><span class="string">'abc'</span>) == True
(<span class="string">'b' </span><span class="kw">in </span><span class="string">'abc'</span>) == True
(<span class="string">'z' </span><span class="kw">in </span><span class="string">'abc'</span>) == False</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.plus" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#653-655">Source</a><h4 class="code-header">fn <a href="#method.plus" class="fn">plus</a>(&amp;self, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Apply the <code>+</code> unary operator to the current value.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>+<span class="number">1 </span>== <span class="number">1</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.minus" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#666-668">Source</a><h4 class="code-header">fn <a href="#method.minus" class="fn">minus</a>(&amp;self, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Apply the <code>-</code> unary operator to the current value.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>-(<span class="number">1</span>) == -<span class="number">1</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.radd" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#672-674">Source</a><h4 class="code-header">fn <a href="#method.radd" class="fn">radd</a>(&amp;self, _lhs: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Add with the arguments the other way around.
Normal <code>add</code> should return <code>None</code> in order for it to be evaluated.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#690-692">Source</a><h4 class="code-header">fn <a href="#method.add" class="fn">add</a>(&amp;self, _rhs: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Add <code>other</code> to the current value. Pass both self and
the Value form of self as original. Should return <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>
to fall through to <code>radd</code>.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">1 </span>+ <span class="number">2 </span>== <span class="number">3
</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="number">2</span>, <span class="number">3</span>] == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="string">'abc' </span>+ <span class="string">'def' </span>== <span class="string">'abcdef'
</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">2</span>, <span class="number">3</span>) == (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>)</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#703-705">Source</a><h4 class="code-header">fn <a href="#method.sub" class="fn">sub</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Subtract <code>other</code> from the current value.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">1 </span>- <span class="number">2 </span>== -<span class="number">1</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmul" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#708-711">Source</a><h4 class="code-header">fn <a href="#method.rmul" class="fn">rmul</a>(&amp;self, lhs: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Called on <code>rhs</code> of <code>lhs * rhs</code> when <code>lhs.mul</code> returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.mul" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#727-729">Source</a><h4 class="code-header">fn <a href="#method.mul" class="fn">mul</a>(&amp;self, _rhs: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Multiply the current value with <code>other</code>.</p>
<p>When this function returns <code>None</code>, starlark-rust calls <code>rhs.rmul(lhs)</code>.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">2 </span>* <span class="number">3 </span>== <span class="number">6
</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">3 </span>== [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="string">'abc' </span>* <span class="number">3 </span>== <span class="string">'abcabcabc'
</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) * <span class="number">3 </span>== (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.div" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#741-743">Source</a><h4 class="code-header">fn <a href="#method.div" class="fn">div</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Divide the current value by <code>other</code>. Always results in a float value.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">4 </span>/ <span class="number">2.0 </span>== <span class="number">2.0
7 </span>/ <span class="number">2 </span>== <span class="number">3.5</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.percent" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#772-774">Source</a><h4 class="code-header">fn <a href="#method.percent" class="fn">percent</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Apply the percent operator between the current value and <code>other</code>. Usually used on
strings, as per
<a href="https://github.com/bazelbuild/starlark/blob/master/spec.md#string-interpolation">the Starlark spec</a>.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">5 </span>% <span class="number">3 </span>== <span class="number">2
</span>-<span class="number">5 </span>% -<span class="number">3 </span>== -<span class="number">2
5 </span>% -<span class="number">3 </span>== -<span class="number">1
</span>-<span class="number">5 </span>% <span class="number">3 </span>== <span class="number">1
5.5 </span>% <span class="number">3.0 </span>== <span class="number">2.5
</span>-<span class="number">5.5 </span>% <span class="number">3.0 </span>== <span class="number">0.5
5.5 </span>% -<span class="number">3.0 </span>== -<span class="number">0.5
</span>-<span class="number">5.5 </span>% -<span class="number">3.0 </span>== -<span class="number">2.5
</span><span class="string">"a %s c" </span>% <span class="number">3 </span>== <span class="string">"a 3 c"
"Hello %s, your score is %d" </span>% (<span class="string">"Bob"</span>, <span class="number">75</span>) == <span class="string">"Hello Bob, your score is 75"
"%d %o %x" </span>% (<span class="number">65</span>, <span class="number">65</span>, <span class="number">65</span>) == <span class="string">"65 101 41"
"%d" </span>% <span class="number">12345678901234567890 </span>== <span class="string">"12345678901234567890"
"Hello %s, welcome" </span>% <span class="string">"Bob" </span>== <span class="string">"Hello Bob, welcome"
"%s" </span>% (<span class="number">1</span>,) == <span class="string">"1"
"%s" </span>% ((<span class="number">1</span>,),) == <span class="string">"(1,)"
"%s" </span>% [<span class="number">1</span>] == <span class="string">"[1]"
"test" </span>% () == <span class="string">"test"</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.floor_div" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#793-795">Source</a><h4 class="code-header">fn <a href="#method.floor_div" class="fn">floor_div</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Floor division between the current value and <code>other</code>.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">7 </span><span class="comment">// 2 == 3
</span>-<span class="number">7 </span><span class="comment">// -2 == 3
</span><span class="number">7 </span><span class="comment">// -2 == -4
</span>-<span class="number">7 </span><span class="comment">// 2 == -4
</span><span class="number">7.0 </span><span class="comment">// 2.0 == 3.0
</span>-<span class="number">7.0 </span><span class="comment">// -2.0 == 3.0
</span><span class="number">7.0 </span><span class="comment">// -2.0 == -4.0
</span>-<span class="number">7.0 </span><span class="comment">// 2.0 == -4.0
</span><span class="number">3.0 </span><span class="comment">// 2.0 == 1.0</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bit_and" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#798-800">Source</a><h4 class="code-header">fn <a href="#method.bit_and" class="fn">bit_and</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Bitwise <code>&amp;</code> operator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bit_or" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#814-816">Source</a><h4 class="code-header">fn <a href="#method.bit_or" class="fn">bit_or</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Bitwise <code>|</code> operator.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">0xb00f </span>| <span class="number">0x0ee0 </span>== <span class="number">0xbeef
4 </span>| <span class="number">7 </span>== <span class="number">7
</span>{<span class="number">1</span>: <span class="number">2</span>} | {<span class="number">3</span>: <span class="number">4</span>} == {<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>}
{<span class="number">1</span>: <span class="number">2</span>} | {<span class="number">1</span>: <span class="number">3</span>} == {<span class="number">1</span>: <span class="number">3</span>}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bit_xor" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#819-821">Source</a><h4 class="code-header">fn <a href="#method.bit_xor" class="fn">bit_xor</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Bitwise <code>^</code> operator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bit_not" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#824-826">Source</a><h4 class="code-header">fn <a href="#method.bit_not" class="fn">bit_not</a>(&amp;self, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Bitwise <code>~</code> operator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.left_shift" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#829-831">Source</a><h4 class="code-header">fn <a href="#method.left_shift" class="fn">left_shift</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Bitwise <code>&lt;&lt;</code> operator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.right_shift" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#834-836">Source</a><h4 class="code-header">fn <a href="#method.right_shift" class="fn">right_shift</a>(&amp;self, other: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _heap: &amp;'v <a class="struct" href="struct.Heap.html" title="struct starlark::values::Heap">Heap</a>) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;&gt;</h4></section></summary><div class="docblock"><p>Bitwise <code>&gt;&gt;</code> operator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bin_op_ty" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#839-841">Source</a><h4 class="code-header">fn <a href="#method.bin_op_ty" class="fn">bin_op_ty</a>(_op: <a class="enum" href="../typing/enum.TypingBinOp.html" title="enum starlark::typing::TypingBinOp">TypingBinOp</a>, _rhs: &amp;<a class="enum" href="../typing/enum.TyBasic.html" title="enum starlark::typing::TyBasic">TyBasic</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a>&gt;</h4></section></summary><div class="docblock"><p>Typecheck <code>this op rhs</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rbin_op_ty" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#844-846">Source</a><h4 class="code-header">fn <a href="#method.rbin_op_ty" class="fn">rbin_op_ty</a>(_lhs: &amp;<a class="enum" href="../typing/enum.TyBasic.html" title="enum starlark::typing::TyBasic">TyBasic</a>, _op: <a class="enum" href="../typing/enum.TypingBinOp.html" title="enum starlark::typing::TypingBinOp">TypingBinOp</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../typing/struct.Ty.html" title="struct starlark::typing::Ty">Ty</a>&gt;</h4></section></summary><div class="docblock"><p>Typecheck <code>lhs op this</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.export_as" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#849-857">Source</a><h4 class="code-header">fn <a href="#method.export_as" class="fn">export_as</a>(
    &amp;self,
    _variable_name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
    _eval: &amp;mut <a class="struct" href="../eval/struct.Evaluator.html" title="struct starlark::eval::Evaluator">Evaluator</a>&lt;'v, '_, '_&gt;,
) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Called when exporting a value under a specific name,</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_at" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#869-873">Source</a><h4 class="code-header">fn <a href="#method.set_at" class="fn">set_at</a>(&amp;self, _index: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;, _new_value: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Set the value at <code>index</code> with the new value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>v = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
v[<span class="number">1</span>] = <span class="number">1
</span>v[<span class="number">2</span>] = [<span class="number">2</span>,<span class="number">3</span>]
v == [<span class="number">1</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]]</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_attr" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#877-879">Source</a><h4 class="code-header">fn <a href="#method.set_attr" class="fn">set_attr</a>(&amp;self, attribute: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, _new_value: <a class="struct" href="struct.Value.html" title="struct starlark::values::Value">Value</a>&lt;'v&gt;) -&gt; <a class="type" href="../type.Result.html" title="type starlark::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Set the attribute named <code>attribute</code> of the current value to
<code>value</code> (e.g. <code>a.attribute = value</code>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.provide" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#887-889">Source</a><h4 class="code-header">fn <a href="#method.provide" class="fn">provide</a>(&amp;'v self, demand: &amp;mut <a class="struct" href="struct.Demand.html" title="struct starlark::values::Demand">Demand</a>&lt;'_, 'v&gt;)</h4></section></summary><div class="docblock"><p>Dynamically provide values based on type.</p>
<p>Value can be fetched using <a href="struct.Value.html#method.request_value" title="method starlark::values::Value::request_value"><code>Value::request_value</code></a>.</p>
<p>The API is based on
<a href="https://doc.rust-lang.org/std/any/trait.Provider.html">std::any::Provider</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_freeze_directly" class="method"><a class="src rightside" href="../../src/starlark/values/traits.rs.html#908-910">Source</a><h4 class="code-header">fn <a href="#method.try_freeze_directly" class="fn">try_freeze_directly</a>(
    &amp;self,
    _freezer: &amp;<a class="struct" href="struct.Freezer.html" title="struct starlark::values::Freezer">Freezer</a>&lt;'_&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.FreezeResult.html" title="type starlark::values::FreezeResult">FreezeResult</a>&lt;<a class="struct" href="struct.FrozenValue.html" title="struct starlark::values::FrozenValue">FrozenValue</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>When freezing, this function is called on the value first and can return a <code>FrozenValue</code>
directly to bypass the freeze impl.</p>
<p>Most types, when being frozen, want to implement their <code>Freeze</code> by converting themselves to
a value of a new type that is then allocated in the frozen heap. In this case, the <code>Freeze</code>
trait should just be used.</p>
<p>This function is needed in the rare case when that is not appropriate - most typically, when
freezing some values, it may be possible to return a statically allocated value instead of
allocating a new one. In such cases, this function can be implemented to enable that.</p>
<p>FIXME(JakobDegen):</p>
<ol>
<li>This behavior really belongs on the freeze trait, not here</li>
<li>We need to verify that the returned <code>FrozenValue</code>’s underlying type agrees with the
type on the <code>Freeze</code> implementation</li>
<li>We may want to make it possible to <em>only</em> implement this, thereby not allowing by-value
freezes of the type.</li>
</ol>
</div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/nightly/reference/items/traits.html#dyn-compatibility">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><details class="toggle implementors-toggle"><summary><section id="impl-StarlarkValue%3C'v%3E-for-StarlarkBool" class="impl"><a class="src rightside" href="../../src/starlark/values/types/bool/value.rs.html#66-116">Source</a><a href="#impl-StarlarkValue%3C'v%3E-for-StarlarkBool" class="anchor">§</a><h3 class="code-header">impl&lt;'v&gt; <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt; for <a class="struct" href="bool/struct.StarlarkBool.html" title="struct starlark::values::bool::StarlarkBool">StarlarkBool</a></h3><div class="docblock"><p>Define the bool type</p>
</div></section></summary><div class="impl-items"><section id="associatedconstant.TYPE-1" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/starlark/values/types/bool/value.rs.html#64-116">Source</a><a href="#associatedconstant.TYPE-1" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = BOOL_TYPE</h4></section><section id="associatedtype.Canonical-1" class="associatedtype trait-impl"><a class="src rightside" href="../../src/starlark/values/types/bool/value.rs.html#64-116">Source</a><a href="#associatedtype.Canonical-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a> = <a class="struct" href="bool/struct.StarlarkBool.html" title="struct starlark::values::bool::StarlarkBool">StarlarkBool</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-StarlarkValue%3C'v%3E-for-StarlarkFloat" class="impl"><a class="src rightside" href="../../src/starlark/values/types/float/float.rs.html#254-330">Source</a><a href="#impl-StarlarkValue%3C'v%3E-for-StarlarkFloat" class="anchor">§</a><h3 class="code-header">impl&lt;'v&gt; <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt; for <a class="struct" href="float/struct.StarlarkFloat.html" title="struct starlark::values::float::StarlarkFloat">StarlarkFloat</a></h3></section></summary><div class="impl-items"><section id="associatedconstant.TYPE-2" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/starlark/values/types/float/float.rs.html#254-330">Source</a><a href="#associatedconstant.TYPE-2" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = StarlarkFloat::TYPE</h4></section><section id="associatedtype.Canonical-2" class="associatedtype trait-impl"><a class="src rightside" href="../../src/starlark/values/types/float/float.rs.html#254-330">Source</a><a href="#associatedtype.Canonical-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a> = <a class="struct" href="float/struct.StarlarkFloat.html" title="struct starlark::values::float::StarlarkFloat">StarlarkFloat</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-StarlarkValue%3C'v%3E-for-NoneType" class="impl"><a class="src rightside" href="../../src/starlark/values/types/none/none_type.rs.html#59-92">Source</a><a href="#impl-StarlarkValue%3C'v%3E-for-NoneType" class="anchor">§</a><h3 class="code-header">impl&lt;'v&gt; <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt; for <a class="struct" href="none/struct.NoneType.html" title="struct starlark::values::none::NoneType">NoneType</a></h3><div class="docblock"><p>Define the NoneType type</p>
</div></section></summary><div class="impl-items"><section id="associatedconstant.TYPE-3" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/starlark/values/types/none/none_type.rs.html#57-92">Source</a><a href="#associatedconstant.TYPE-3" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = NoneType::TYPE</h4></section><section id="associatedtype.Canonical-3" class="associatedtype trait-impl"><a class="src rightside" href="../../src/starlark/values/types/none/none_type.rs.html#57-92">Source</a><a href="#associatedtype.Canonical-3" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a> = <a class="struct" href="none/struct.NoneType.html" title="struct starlark::values::none::NoneType">NoneType</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-StarlarkValue%3C'v%3E-for-Range" class="impl"><a class="src rightside" href="../../src/starlark/values/types/range/range_type.rs.html#106-251">Source</a><a href="#impl-StarlarkValue%3C'v%3E-for-Range" class="anchor">§</a><h3 class="code-header">impl&lt;'v&gt; <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt; for <a class="struct" href="range/struct.Range.html" title="struct starlark::values::range::Range">Range</a></h3></section></summary><div class="impl-items"><section id="associatedconstant.TYPE-4" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/starlark/values/types/range/range_type.rs.html#106-251">Source</a><a href="#associatedconstant.TYPE-4" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = Range::TYPE</h4></section><section id="associatedtype.Canonical-4" class="associatedtype trait-impl"><a class="src rightside" href="../../src/starlark/values/types/range/range_type.rs.html#106-251">Source</a><a href="#associatedtype.Canonical-4" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a> = <a class="struct" href="range/struct.Range.html" title="struct starlark::values::range::Range">Range</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-StarlarkValue%3C'v%3E-for-StarlarkStr" class="impl"><a class="src rightside" href="../../src/starlark/values/types/string/str_type.rs.html#217-363">Source</a><a href="#impl-StarlarkValue%3C'v%3E-for-StarlarkStr" class="anchor">§</a><h3 class="code-header">impl&lt;'v&gt; <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt; for <a class="struct" href="string/struct.StarlarkStr.html" title="struct starlark::values::string::StarlarkStr">StarlarkStr</a></h3></section></summary><div class="impl-items"><section id="associatedconstant.TYPE-5" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/starlark/values/types/string/str_type.rs.html#217-363">Source</a><a href="#associatedconstant.TYPE-5" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = STRING_TYPE</h4></section><section id="associatedtype.Canonical-5" class="associatedtype trait-impl"><a class="src rightside" href="../../src/starlark/values/types/string/str_type.rs.html#217-363">Source</a><a href="#associatedtype.Canonical-5" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a> = <a class="struct" href="string/struct.StarlarkStr.html" title="struct starlark::values::string::StarlarkStr">StarlarkStr</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-StarlarkValue%3C'v%3E-for-StarlarkAnyComplex%3CT%3E" class="impl"><a class="src rightside" href="../../src/starlark/values/types/any_complex.rs.html#86-92">Source</a><a href="#impl-StarlarkValue%3C'v%3E-for-StarlarkAnyComplex%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'v, T&gt; <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt; for <a class="struct" href="any_complex/struct.StarlarkAnyComplex.html" title="struct starlark::values::any_complex::StarlarkAnyComplex">StarlarkAnyComplex</a>&lt;T&gt;<div class="where">where
    T: Allocative + <a class="trait" href="../any/trait.ProvidesStaticType.html" title="trait starlark::any::ProvidesStaticType">ProvidesStaticType</a>&lt;'v&gt; + 'v,
    T::<a class="associatedtype" href="../any/trait.ProvidesStaticType.html#associatedtype.StaticType" title="type starlark::any::ProvidesStaticType::StaticType">StaticType</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><section id="associatedconstant.TYPE-6" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/starlark/values/types/any_complex.rs.html#86-92">Source</a><a href="#associatedconstant.TYPE-6" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;any_complex&quot;</h4></section><section id="associatedtype.Canonical-6" class="associatedtype trait-impl"><a class="src rightside" href="../../src/starlark/values/types/any_complex.rs.html#91">Source</a><a href="#associatedtype.Canonical-6" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a> = <a class="struct" href="any_complex/struct.StarlarkAnyComplex.html" title="struct starlark::values::any_complex::StarlarkAnyComplex">StarlarkAnyComplex</a>&lt;T&gt;</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-StarlarkValue%3C'v%3E-for-StarlarkAny%3CT%3E" class="impl"><a class="src rightside" href="../../src/starlark/values/types/any.rs.html#100-102">Source</a><a href="#impl-StarlarkValue%3C'v%3E-for-StarlarkAny%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'v, T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static&gt; <a class="trait" href="trait.StarlarkValue.html" title="trait starlark::values::StarlarkValue">StarlarkValue</a>&lt;'v&gt; for <a class="struct" href="any/struct.StarlarkAny.html" title="struct starlark::values::any::StarlarkAny">StarlarkAny</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><section id="associatedconstant.TYPE-7" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/starlark/values/types/any.rs.html#100-102">Source</a><a href="#associatedconstant.TYPE-7" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.TYPE" class="constant">TYPE</a>: &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;any&quot;</h4></section><section id="associatedtype.Canonical-7" class="associatedtype trait-impl"><a class="src rightside" href="../../src/starlark/values/types/any.rs.html#101">Source</a><a href="#associatedtype.Canonical-7" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Canonical" class="associatedtype">Canonical</a> = <a class="struct" href="any/struct.StarlarkAny.html" title="struct starlark::values::any::StarlarkAny">StarlarkAny</a>&lt;T&gt;</h4></section></div></details></div><script src="../../trait.impl/starlark/values/traits/trait.StarlarkValue.js" async></script></section></div></main></body></html>